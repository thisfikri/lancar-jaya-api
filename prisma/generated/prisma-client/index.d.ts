// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  appSetting: (where?: AppSettingWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  folder: (where?: FolderWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userSetting: (where?: UserSettingWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  appSetting: (where: AppSettingWhereUniqueInput) => AppSettingNullablePromise;
  appSettings: (args?: {
    where?: AppSettingWhereInput;
    orderBy?: AppSettingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AppSetting>;
  appSettingsConnection: (args?: {
    where?: AppSettingWhereInput;
    orderBy?: AppSettingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AppSettingConnectionPromise;
  file: (where: FileWhereUniqueInput) => FileNullablePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  folder: (where: FolderWhereUniqueInput) => FolderNullablePromise;
  folders: (args?: {
    where?: FolderWhereInput;
    orderBy?: FolderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Folder>;
  foldersConnection: (args?: {
    where?: FolderWhereInput;
    orderBy?: FolderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FolderConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userSetting: (
    where: UserSettingWhereUniqueInput
  ) => UserSettingNullablePromise;
  userSettings: (args?: {
    where?: UserSettingWhereInput;
    orderBy?: UserSettingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserSetting>;
  userSettingsConnection: (args?: {
    where?: UserSettingWhereInput;
    orderBy?: UserSettingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserSettingConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAppSetting: (data: AppSettingCreateInput) => AppSettingPromise;
  updateAppSetting: (args: {
    data: AppSettingUpdateInput;
    where: AppSettingWhereUniqueInput;
  }) => AppSettingPromise;
  updateManyAppSettings: (args: {
    data: AppSettingUpdateManyMutationInput;
    where?: AppSettingWhereInput;
  }) => BatchPayloadPromise;
  upsertAppSetting: (args: {
    where: AppSettingWhereUniqueInput;
    create: AppSettingCreateInput;
    update: AppSettingUpdateInput;
  }) => AppSettingPromise;
  deleteAppSetting: (where: AppSettingWhereUniqueInput) => AppSettingPromise;
  deleteManyAppSettings: (where?: AppSettingWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createFolder: (data: FolderCreateInput) => FolderPromise;
  updateFolder: (args: {
    data: FolderUpdateInput;
    where: FolderWhereUniqueInput;
  }) => FolderPromise;
  updateManyFolders: (args: {
    data: FolderUpdateManyMutationInput;
    where?: FolderWhereInput;
  }) => BatchPayloadPromise;
  upsertFolder: (args: {
    where: FolderWhereUniqueInput;
    create: FolderCreateInput;
    update: FolderUpdateInput;
  }) => FolderPromise;
  deleteFolder: (where: FolderWhereUniqueInput) => FolderPromise;
  deleteManyFolders: (where?: FolderWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserSetting: (data: UserSettingCreateInput) => UserSettingPromise;
  updateUserSetting: (args: {
    data: UserSettingUpdateInput;
    where: UserSettingWhereUniqueInput;
  }) => UserSettingPromise;
  updateManyUserSettings: (args: {
    data: UserSettingUpdateManyMutationInput;
    where?: UserSettingWhereInput;
  }) => BatchPayloadPromise;
  upsertUserSetting: (args: {
    where: UserSettingWhereUniqueInput;
    create: UserSettingCreateInput;
    update: UserSettingUpdateInput;
  }) => UserSettingPromise;
  deleteUserSetting: (where: UserSettingWhereUniqueInput) => UserSettingPromise;
  deleteManyUserSettings: (
    where?: UserSettingWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  appSetting: (
    where?: AppSettingSubscriptionWhereInput
  ) => AppSettingSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  folder: (
    where?: FolderSubscriptionWhereInput
  ) => FolderSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userSetting: (
    where?: UserSettingSubscriptionWhereInput
  ) => UserSettingSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AppSettingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "value_ASC"
  | "value_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "size_ASC"
  | "size_DESC"
  | "path_ASC"
  | "path_DESC"
  | "folderPath_ASC"
  | "folderPath_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FolderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "parentFolder_ASC"
  | "parentFolder_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "email_ASC"
  | "email_DESC"
  | "role_ASC"
  | "role_DESC"
  | "storagePath_ASC"
  | "storagePath_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "profilePic_ASC"
  | "profilePic_DESC";

export type UserSettingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "value_ASC"
  | "value_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AppSettingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AppSettingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  userId?: Maybe<ID_Input>;
  userId_not?: Maybe<ID_Input>;
  userId_in?: Maybe<ID_Input[] | ID_Input>;
  userId_not_in?: Maybe<ID_Input[] | ID_Input>;
  userId_lt?: Maybe<ID_Input>;
  userId_lte?: Maybe<ID_Input>;
  userId_gt?: Maybe<ID_Input>;
  userId_gte?: Maybe<ID_Input>;
  userId_contains?: Maybe<ID_Input>;
  userId_not_contains?: Maybe<ID_Input>;
  userId_starts_with?: Maybe<ID_Input>;
  userId_not_starts_with?: Maybe<ID_Input>;
  userId_ends_with?: Maybe<ID_Input>;
  userId_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AppSettingWhereInput[] | AppSettingWhereInput>;
  OR?: Maybe<AppSettingWhereInput[] | AppSettingWhereInput>;
  NOT?: Maybe<AppSettingWhereInput[] | AppSettingWhereInput>;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  path?: Maybe<String>;
}>;

export interface FileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  size?: Maybe<Int>;
  size_not?: Maybe<Int>;
  size_in?: Maybe<Int[] | Int>;
  size_not_in?: Maybe<Int[] | Int>;
  size_lt?: Maybe<Int>;
  size_lte?: Maybe<Int>;
  size_gt?: Maybe<Int>;
  size_gte?: Maybe<Int>;
  path?: Maybe<String>;
  path_not?: Maybe<String>;
  path_in?: Maybe<String[] | String>;
  path_not_in?: Maybe<String[] | String>;
  path_lt?: Maybe<String>;
  path_lte?: Maybe<String>;
  path_gt?: Maybe<String>;
  path_gte?: Maybe<String>;
  path_contains?: Maybe<String>;
  path_not_contains?: Maybe<String>;
  path_starts_with?: Maybe<String>;
  path_not_starts_with?: Maybe<String>;
  path_ends_with?: Maybe<String>;
  path_not_ends_with?: Maybe<String>;
  folderPath?: Maybe<String>;
  folderPath_not?: Maybe<String>;
  folderPath_in?: Maybe<String[] | String>;
  folderPath_not_in?: Maybe<String[] | String>;
  folderPath_lt?: Maybe<String>;
  folderPath_lte?: Maybe<String>;
  folderPath_gt?: Maybe<String>;
  folderPath_gte?: Maybe<String>;
  folderPath_contains?: Maybe<String>;
  folderPath_not_contains?: Maybe<String>;
  folderPath_starts_with?: Maybe<String>;
  folderPath_not_starts_with?: Maybe<String>;
  folderPath_ends_with?: Maybe<String>;
  folderPath_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FileWhereInput[] | FileWhereInput>;
  OR?: Maybe<FileWhereInput[] | FileWhereInput>;
  NOT?: Maybe<FileWhereInput[] | FileWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  role?: Maybe<String>;
  role_not?: Maybe<String>;
  role_in?: Maybe<String[] | String>;
  role_not_in?: Maybe<String[] | String>;
  role_lt?: Maybe<String>;
  role_lte?: Maybe<String>;
  role_gt?: Maybe<String>;
  role_gte?: Maybe<String>;
  role_contains?: Maybe<String>;
  role_not_contains?: Maybe<String>;
  role_starts_with?: Maybe<String>;
  role_not_starts_with?: Maybe<String>;
  role_ends_with?: Maybe<String>;
  role_not_ends_with?: Maybe<String>;
  files_every?: Maybe<FileWhereInput>;
  files_some?: Maybe<FileWhereInput>;
  files_none?: Maybe<FileWhereInput>;
  storagePath?: Maybe<String>;
  storagePath_not?: Maybe<String>;
  storagePath_in?: Maybe<String[] | String>;
  storagePath_not_in?: Maybe<String[] | String>;
  storagePath_lt?: Maybe<String>;
  storagePath_lte?: Maybe<String>;
  storagePath_gt?: Maybe<String>;
  storagePath_gte?: Maybe<String>;
  storagePath_contains?: Maybe<String>;
  storagePath_not_contains?: Maybe<String>;
  storagePath_starts_with?: Maybe<String>;
  storagePath_not_starts_with?: Maybe<String>;
  storagePath_ends_with?: Maybe<String>;
  storagePath_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  profilePic?: Maybe<String>;
  profilePic_not?: Maybe<String>;
  profilePic_in?: Maybe<String[] | String>;
  profilePic_not_in?: Maybe<String[] | String>;
  profilePic_lt?: Maybe<String>;
  profilePic_lte?: Maybe<String>;
  profilePic_gt?: Maybe<String>;
  profilePic_gte?: Maybe<String>;
  profilePic_contains?: Maybe<String>;
  profilePic_not_contains?: Maybe<String>;
  profilePic_starts_with?: Maybe<String>;
  profilePic_not_starts_with?: Maybe<String>;
  profilePic_ends_with?: Maybe<String>;
  profilePic_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export type FolderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FolderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  files_every?: Maybe<FileWhereInput>;
  files_some?: Maybe<FileWhereInput>;
  files_none?: Maybe<FileWhereInput>;
  parentFolder?: Maybe<ID_Input>;
  parentFolder_not?: Maybe<ID_Input>;
  parentFolder_in?: Maybe<ID_Input[] | ID_Input>;
  parentFolder_not_in?: Maybe<ID_Input[] | ID_Input>;
  parentFolder_lt?: Maybe<ID_Input>;
  parentFolder_lte?: Maybe<ID_Input>;
  parentFolder_gt?: Maybe<ID_Input>;
  parentFolder_gte?: Maybe<ID_Input>;
  parentFolder_contains?: Maybe<ID_Input>;
  parentFolder_not_contains?: Maybe<ID_Input>;
  parentFolder_starts_with?: Maybe<ID_Input>;
  parentFolder_not_starts_with?: Maybe<ID_Input>;
  parentFolder_ends_with?: Maybe<ID_Input>;
  parentFolder_not_ends_with?: Maybe<ID_Input>;
  createdBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FolderWhereInput[] | FolderWhereInput>;
  OR?: Maybe<FolderWhereInput[] | FolderWhereInput>;
  NOT?: Maybe<FolderWhereInput[] | FolderWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
  email?: Maybe<String>;
  storagePath?: Maybe<String>;
  profilePic?: Maybe<String>;
}>;

export type UserSettingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserSettingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  userId?: Maybe<ID_Input>;
  userId_not?: Maybe<ID_Input>;
  userId_in?: Maybe<ID_Input[] | ID_Input>;
  userId_not_in?: Maybe<ID_Input[] | ID_Input>;
  userId_lt?: Maybe<ID_Input>;
  userId_lte?: Maybe<ID_Input>;
  userId_gt?: Maybe<ID_Input>;
  userId_gte?: Maybe<ID_Input>;
  userId_contains?: Maybe<ID_Input>;
  userId_not_contains?: Maybe<ID_Input>;
  userId_starts_with?: Maybe<ID_Input>;
  userId_not_starts_with?: Maybe<ID_Input>;
  userId_ends_with?: Maybe<ID_Input>;
  userId_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserSettingWhereInput[] | UserSettingWhereInput>;
  OR?: Maybe<UserSettingWhereInput[] | UserSettingWhereInput>;
  NOT?: Maybe<UserSettingWhereInput[] | UserSettingWhereInput>;
}

export interface AppSettingCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  value: String;
  userId: ID_Input;
}

export interface AppSettingUpdateInput {
  name?: Maybe<String>;
  value?: Maybe<String>;
  userId?: Maybe<ID_Input>;
}

export interface AppSettingUpdateManyMutationInput {
  name?: Maybe<String>;
  value?: Maybe<String>;
  userId?: Maybe<ID_Input>;
}

export interface FileCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  size: Int;
  path: String;
  folderPath: String;
  createdBy: UserCreateOneWithoutFilesInput;
}

export interface UserCreateOneWithoutFilesInput {
  create?: Maybe<UserCreateWithoutFilesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutFilesInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  username: String;
  password: String;
  email: String;
  role: String;
  storagePath: String;
  profilePic: String;
}

export interface FileUpdateInput {
  name?: Maybe<String>;
  size?: Maybe<Int>;
  path?: Maybe<String>;
  folderPath?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutFilesInput>;
}

export interface UserUpdateOneRequiredWithoutFilesInput {
  create?: Maybe<UserCreateWithoutFilesInput>;
  update?: Maybe<UserUpdateWithoutFilesDataInput>;
  upsert?: Maybe<UserUpsertWithoutFilesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutFilesDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<String>;
  storagePath?: Maybe<String>;
  profilePic?: Maybe<String>;
}

export interface UserUpsertWithoutFilesInput {
  update: UserUpdateWithoutFilesDataInput;
  create: UserCreateWithoutFilesInput;
}

export interface FileUpdateManyMutationInput {
  name?: Maybe<String>;
  size?: Maybe<Int>;
  path?: Maybe<String>;
  folderPath?: Maybe<String>;
}

export interface FolderCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  files?: Maybe<FileCreateManyInput>;
  parentFolder: ID_Input;
  childFolder?: Maybe<FolderCreatechildFolderInput>;
  createdBy: UserCreateOneInput;
}

export interface FileCreateManyInput {
  create?: Maybe<FileCreateInput[] | FileCreateInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
}

export interface FolderCreatechildFolderInput {
  set?: Maybe<ID_Input[] | ID_Input>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  username: String;
  password: String;
  email: String;
  role: String;
  files?: Maybe<FileCreateManyWithoutCreatedByInput>;
  storagePath: String;
  profilePic: String;
}

export interface FileCreateManyWithoutCreatedByInput {
  create?: Maybe<
    FileCreateWithoutCreatedByInput[] | FileCreateWithoutCreatedByInput
  >;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
}

export interface FileCreateWithoutCreatedByInput {
  id?: Maybe<ID_Input>;
  name: String;
  size: Int;
  path: String;
  folderPath: String;
}

export interface FolderUpdateInput {
  name?: Maybe<String>;
  files?: Maybe<FileUpdateManyInput>;
  parentFolder?: Maybe<ID_Input>;
  childFolder?: Maybe<FolderUpdatechildFolderInput>;
  createdBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface FileUpdateManyInput {
  create?: Maybe<FileCreateInput[] | FileCreateInput>;
  update?: Maybe<
    | FileUpdateWithWhereUniqueNestedInput[]
    | FileUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | FileUpsertWithWhereUniqueNestedInput[]
    | FileUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  set?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  disconnect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  deleteMany?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  updateMany?: Maybe<
    FileUpdateManyWithWhereNestedInput[] | FileUpdateManyWithWhereNestedInput
  >;
}

export interface FileUpdateWithWhereUniqueNestedInput {
  where: FileWhereUniqueInput;
  data: FileUpdateDataInput;
}

export interface FileUpdateDataInput {
  name?: Maybe<String>;
  size?: Maybe<Int>;
  path?: Maybe<String>;
  folderPath?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutFilesInput>;
}

export interface FileUpsertWithWhereUniqueNestedInput {
  where: FileWhereUniqueInput;
  update: FileUpdateDataInput;
  create: FileCreateInput;
}

export interface FileScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  size?: Maybe<Int>;
  size_not?: Maybe<Int>;
  size_in?: Maybe<Int[] | Int>;
  size_not_in?: Maybe<Int[] | Int>;
  size_lt?: Maybe<Int>;
  size_lte?: Maybe<Int>;
  size_gt?: Maybe<Int>;
  size_gte?: Maybe<Int>;
  path?: Maybe<String>;
  path_not?: Maybe<String>;
  path_in?: Maybe<String[] | String>;
  path_not_in?: Maybe<String[] | String>;
  path_lt?: Maybe<String>;
  path_lte?: Maybe<String>;
  path_gt?: Maybe<String>;
  path_gte?: Maybe<String>;
  path_contains?: Maybe<String>;
  path_not_contains?: Maybe<String>;
  path_starts_with?: Maybe<String>;
  path_not_starts_with?: Maybe<String>;
  path_ends_with?: Maybe<String>;
  path_not_ends_with?: Maybe<String>;
  folderPath?: Maybe<String>;
  folderPath_not?: Maybe<String>;
  folderPath_in?: Maybe<String[] | String>;
  folderPath_not_in?: Maybe<String[] | String>;
  folderPath_lt?: Maybe<String>;
  folderPath_lte?: Maybe<String>;
  folderPath_gt?: Maybe<String>;
  folderPath_gte?: Maybe<String>;
  folderPath_contains?: Maybe<String>;
  folderPath_not_contains?: Maybe<String>;
  folderPath_starts_with?: Maybe<String>;
  folderPath_not_starts_with?: Maybe<String>;
  folderPath_ends_with?: Maybe<String>;
  folderPath_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  OR?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  NOT?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
}

export interface FileUpdateManyWithWhereNestedInput {
  where: FileScalarWhereInput;
  data: FileUpdateManyDataInput;
}

export interface FileUpdateManyDataInput {
  name?: Maybe<String>;
  size?: Maybe<Int>;
  path?: Maybe<String>;
  folderPath?: Maybe<String>;
}

export interface FolderUpdatechildFolderInput {
  set?: Maybe<ID_Input[] | ID_Input>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<String>;
  files?: Maybe<FileUpdateManyWithoutCreatedByInput>;
  storagePath?: Maybe<String>;
  profilePic?: Maybe<String>;
}

export interface FileUpdateManyWithoutCreatedByInput {
  create?: Maybe<
    FileCreateWithoutCreatedByInput[] | FileCreateWithoutCreatedByInput
  >;
  delete?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  set?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  disconnect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  update?: Maybe<
    | FileUpdateWithWhereUniqueWithoutCreatedByInput[]
    | FileUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | FileUpsertWithWhereUniqueWithoutCreatedByInput[]
    | FileUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  updateMany?: Maybe<
    FileUpdateManyWithWhereNestedInput[] | FileUpdateManyWithWhereNestedInput
  >;
}

export interface FileUpdateWithWhereUniqueWithoutCreatedByInput {
  where: FileWhereUniqueInput;
  data: FileUpdateWithoutCreatedByDataInput;
}

export interface FileUpdateWithoutCreatedByDataInput {
  name?: Maybe<String>;
  size?: Maybe<Int>;
  path?: Maybe<String>;
  folderPath?: Maybe<String>;
}

export interface FileUpsertWithWhereUniqueWithoutCreatedByInput {
  where: FileWhereUniqueInput;
  update: FileUpdateWithoutCreatedByDataInput;
  create: FileCreateWithoutCreatedByInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface FolderUpdateManyMutationInput {
  name?: Maybe<String>;
  parentFolder?: Maybe<ID_Input>;
  childFolder?: Maybe<FolderUpdatechildFolderInput>;
}

export interface UserUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<String>;
  files?: Maybe<FileUpdateManyWithoutCreatedByInput>;
  storagePath?: Maybe<String>;
  profilePic?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<String>;
  storagePath?: Maybe<String>;
  profilePic?: Maybe<String>;
}

export interface UserSettingCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  value: String;
  userId: ID_Input;
}

export interface UserSettingUpdateInput {
  name?: Maybe<String>;
  value?: Maybe<String>;
  userId?: Maybe<ID_Input>;
}

export interface UserSettingUpdateManyMutationInput {
  name?: Maybe<String>;
  value?: Maybe<String>;
  userId?: Maybe<ID_Input>;
}

export interface AppSettingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AppSettingWhereInput>;
  AND?: Maybe<
    AppSettingSubscriptionWhereInput[] | AppSettingSubscriptionWhereInput
  >;
  OR?: Maybe<
    AppSettingSubscriptionWhereInput[] | AppSettingSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AppSettingSubscriptionWhereInput[] | AppSettingSubscriptionWhereInput
  >;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FileWhereInput>;
  AND?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  OR?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  NOT?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
}

export interface FolderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FolderWhereInput>;
  AND?: Maybe<FolderSubscriptionWhereInput[] | FolderSubscriptionWhereInput>;
  OR?: Maybe<FolderSubscriptionWhereInput[] | FolderSubscriptionWhereInput>;
  NOT?: Maybe<FolderSubscriptionWhereInput[] | FolderSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserSettingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserSettingWhereInput>;
  AND?: Maybe<
    UserSettingSubscriptionWhereInput[] | UserSettingSubscriptionWhereInput
  >;
  OR?: Maybe<
    UserSettingSubscriptionWhereInput[] | UserSettingSubscriptionWhereInput
  >;
  NOT?: Maybe<
    UserSettingSubscriptionWhereInput[] | UserSettingSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AppSetting {
  id: ID_Output;
  name: String;
  value: String;
  userId: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AppSettingPromise extends Promise<AppSetting>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<String>;
  userId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AppSettingSubscription
  extends Promise<AsyncIterator<AppSetting>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AppSettingNullablePromise
  extends Promise<AppSetting | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<String>;
  userId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AppSettingConnection {
  pageInfo: PageInfo;
  edges: AppSettingEdge[];
}

export interface AppSettingConnectionPromise
  extends Promise<AppSettingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AppSettingEdge>>() => T;
  aggregate: <T = AggregateAppSettingPromise>() => T;
}

export interface AppSettingConnectionSubscription
  extends Promise<AsyncIterator<AppSettingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AppSettingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAppSettingSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AppSettingEdge {
  node: AppSetting;
  cursor: String;
}

export interface AppSettingEdgePromise
  extends Promise<AppSettingEdge>,
    Fragmentable {
  node: <T = AppSettingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AppSettingEdgeSubscription
  extends Promise<AsyncIterator<AppSettingEdge>>,
    Fragmentable {
  node: <T = AppSettingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAppSetting {
  count: Int;
}

export interface AggregateAppSettingPromise
  extends Promise<AggregateAppSetting>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAppSettingSubscription
  extends Promise<AsyncIterator<AggregateAppSetting>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface File {
  id: ID_Output;
  name: String;
  size: Int;
  path: String;
  folderPath: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  size: () => Promise<Int>;
  path: () => Promise<String>;
  folderPath: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  path: () => Promise<AsyncIterator<String>>;
  folderPath: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FileNullablePromise
  extends Promise<File | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  size: () => Promise<Int>;
  path: () => Promise<String>;
  folderPath: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface User {
  id: ID_Output;
  firstName: String;
  lastName: String;
  username: String;
  password: String;
  email: String;
  role: String;
  storagePath: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  profilePic: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<String>;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  storagePath: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  profilePic: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<String>>;
  files: <T = Promise<AsyncIterator<FileSubscription>>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  storagePath: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  profilePic: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<String>;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  storagePath: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  profilePic: () => Promise<String>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Folder {
  id: ID_Output;
  name: String;
  parentFolder: ID_Output;
  childFolder: ID_Output[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FolderPromise extends Promise<Folder>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parentFolder: () => Promise<ID_Output>;
  childFolder: () => Promise<ID_Output[]>;
  createdBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FolderSubscription
  extends Promise<AsyncIterator<Folder>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  files: <T = Promise<AsyncIterator<FileSubscription>>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parentFolder: () => Promise<AsyncIterator<ID_Output>>;
  childFolder: () => Promise<AsyncIterator<ID_Output[]>>;
  createdBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FolderNullablePromise
  extends Promise<Folder | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parentFolder: () => Promise<ID_Output>;
  childFolder: () => Promise<ID_Output[]>;
  createdBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FolderConnection {
  pageInfo: PageInfo;
  edges: FolderEdge[];
}

export interface FolderConnectionPromise
  extends Promise<FolderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FolderEdge>>() => T;
  aggregate: <T = AggregateFolderPromise>() => T;
}

export interface FolderConnectionSubscription
  extends Promise<AsyncIterator<FolderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FolderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFolderSubscription>() => T;
}

export interface FolderEdge {
  node: Folder;
  cursor: String;
}

export interface FolderEdgePromise extends Promise<FolderEdge>, Fragmentable {
  node: <T = FolderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FolderEdgeSubscription
  extends Promise<AsyncIterator<FolderEdge>>,
    Fragmentable {
  node: <T = FolderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFolder {
  count: Int;
}

export interface AggregateFolderPromise
  extends Promise<AggregateFolder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFolderSubscription
  extends Promise<AsyncIterator<AggregateFolder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSetting {
  id: ID_Output;
  name: String;
  value: String;
  userId: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserSettingPromise extends Promise<UserSetting>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<String>;
  userId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSettingSubscription
  extends Promise<AsyncIterator<UserSetting>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSettingNullablePromise
  extends Promise<UserSetting | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<String>;
  userId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSettingConnection {
  pageInfo: PageInfo;
  edges: UserSettingEdge[];
}

export interface UserSettingConnectionPromise
  extends Promise<UserSettingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserSettingEdge>>() => T;
  aggregate: <T = AggregateUserSettingPromise>() => T;
}

export interface UserSettingConnectionSubscription
  extends Promise<AsyncIterator<UserSettingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserSettingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSettingSubscription>() => T;
}

export interface UserSettingEdge {
  node: UserSetting;
  cursor: String;
}

export interface UserSettingEdgePromise
  extends Promise<UserSettingEdge>,
    Fragmentable {
  node: <T = UserSettingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserSettingEdgeSubscription
  extends Promise<AsyncIterator<UserSettingEdge>>,
    Fragmentable {
  node: <T = UserSettingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserSetting {
  count: Int;
}

export interface AggregateUserSettingPromise
  extends Promise<AggregateUserSetting>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSettingSubscription
  extends Promise<AsyncIterator<AggregateUserSetting>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AppSettingSubscriptionPayload {
  mutation: MutationType;
  node: AppSetting;
  updatedFields: String[];
  previousValues: AppSettingPreviousValues;
}

export interface AppSettingSubscriptionPayloadPromise
  extends Promise<AppSettingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AppSettingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AppSettingPreviousValuesPromise>() => T;
}

export interface AppSettingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AppSettingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AppSettingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AppSettingPreviousValuesSubscription>() => T;
}

export interface AppSettingPreviousValues {
  id: ID_Output;
  name: String;
  value: String;
  userId: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AppSettingPreviousValuesPromise
  extends Promise<AppSettingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<String>;
  userId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AppSettingPreviousValuesSubscription
  extends Promise<AsyncIterator<AppSettingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FilePreviousValues {
  id: ID_Output;
  name: String;
  size: Int;
  path: String;
  folderPath: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  size: () => Promise<Int>;
  path: () => Promise<String>;
  folderPath: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  path: () => Promise<AsyncIterator<String>>;
  folderPath: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FolderSubscriptionPayload {
  mutation: MutationType;
  node: Folder;
  updatedFields: String[];
  previousValues: FolderPreviousValues;
}

export interface FolderSubscriptionPayloadPromise
  extends Promise<FolderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FolderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FolderPreviousValuesPromise>() => T;
}

export interface FolderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FolderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FolderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FolderPreviousValuesSubscription>() => T;
}

export interface FolderPreviousValues {
  id: ID_Output;
  name: String;
  parentFolder: ID_Output;
  childFolder: ID_Output[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FolderPreviousValuesPromise
  extends Promise<FolderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  parentFolder: () => Promise<ID_Output>;
  childFolder: () => Promise<ID_Output[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FolderPreviousValuesSubscription
  extends Promise<AsyncIterator<FolderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  parentFolder: () => Promise<AsyncIterator<ID_Output>>;
  childFolder: () => Promise<AsyncIterator<ID_Output[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  firstName: String;
  lastName: String;
  username: String;
  password: String;
  email: String;
  role: String;
  storagePath: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  profilePic: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<String>;
  storagePath: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  profilePic: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<String>>;
  storagePath: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  profilePic: () => Promise<AsyncIterator<String>>;
}

export interface UserSettingSubscriptionPayload {
  mutation: MutationType;
  node: UserSetting;
  updatedFields: String[];
  previousValues: UserSettingPreviousValues;
}

export interface UserSettingSubscriptionPayloadPromise
  extends Promise<UserSettingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserSettingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserSettingPreviousValuesPromise>() => T;
}

export interface UserSettingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSettingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSettingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserSettingPreviousValuesSubscription>() => T;
}

export interface UserSettingPreviousValues {
  id: ID_Output;
  name: String;
  value: String;
  userId: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserSettingPreviousValuesPromise
  extends Promise<UserSettingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<String>;
  userId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSettingPreviousValuesSubscription
  extends Promise<AsyncIterator<UserSettingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserSetting",
    embedded: false
  },
  {
    name: "AppSetting",
    embedded: false
  },
  {
    name: "Folder",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
